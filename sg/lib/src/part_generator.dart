library sg.part_generator;

import 'dart:async';

import 'package:analyzer/src/generated/element.dart';

import 'cacheable_generator.dart';

/// A [CacheableGenerator] for generating a part file for a target Dart Library.
abstract class PartGenerator extends CacheableGenerator<LibraryElement> {
  const PartGenerator();

  /// **Implementation note: creating the [LibraryElement]**
  ///
  /// The returned [LibraryElement] *must* exclude the contents of parts that
  /// are marked as `@GeneratedPart`.
  ///
  /// ```dart
  /// // Members in `app.generated.dart` – if it even exists – must be excluded.
  /// @GeneratedPart('package:generator_pkg/generator_lib.dart')
  /// part 'app.generated.dart';
  /// ```
  ///
  /// The part generator is guaranteed to not see the content is generated in
  /// previous runs or the members generated by other part generators defined
  /// for the same library.
  @override
  Future<LibraryElement> loadCache(String sourcePath) {
    throw 'not impld';
  }

  @override
  Future<CacheEntry> writeCache(LibraryElement value) {
    throw 'not impld';
  }

  /// This method is implemented by subclasses.
  ///
  /// All of the reading/writing of caches is handled here. The creator of the
  /// generator just gets the `LibraryElement` instance
  /// (without generated parts) and is expected to return the content of a part.
  ///
  /// ### Open design questions
  ///
  ///  * `part of` declarations:
  ///
  ///      * The generated output will need to have a `part of` declaration.
  ///      * Could/should there be a way to handle that?
  ///      * Maybe another override which has the subclass provide the part contents?
  ///      * Or the user can just pick up the library name from the library
  ///        element?
  ///      * Again, since the code is likely generated into the project,
  ///        tools can pick up things like missing or mis-labeled library names.
  ///
  ///  * Convention to report back to the host library that imports are needed?
  ///
  ///  * Utilities to help the part writer discover/access available members
  ///
  ///      * test bullet
  ///
  // TODO: not strictly needed. Here to document pass-through abstract method
  @override
  Future<FileOutput> generate(LibraryElement libraryElement);
}
